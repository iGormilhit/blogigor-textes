<p>Dans le cadre d'un cours de statistiques appliquées à la recherche du 1<sup>er</sup> semestre du <a href="http://www.hesge.ch/heg/formation-base/masters-science/master-science-en-information-documentaire">master en science de l'information</a>, on a touché un peu à <a href="http://www.r-project.org/"><em>R</em></a> et un tout petit peu plus à <a href="http://www.rstudio.com/"><em>RStudio</em></a>, qui n'est qu'un <a href="http://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement"><em>IDE</em></a> pour <em>R</em>, et comme je m'y étais déjà un peu intéressé, j'en ai profité pour aller voir plus loin. Plus loin, c'était peut-être plus près, comme toujours ça dépend des points de vue. Je me suis donc amusé à faire des <em>wordclouds</em>, ou des nuages de mots, afin d'en montrer la fréquence d'utilisation, à partir d'un &quot;corpus&quot;, en l'occurrence le <em>Madame Bovary</em> de Flaubert.</p>
<p>Je me suis principalement basé sur <a href="https://georeferenced.wordpress.com/2013/01/15/rwordcloud/">ce tutoriel</a>.</p>
<h2 id="installation">Installation</h2>
<p>Pour l'installation de <em>R</em>, c'est assez simple et bien documenté. Je l'ai fait sur deux postes, l'un sous <em>Fedora 20</em> avec un simple <code>yum install r-base</code> en root, l'autre sous <em>Debian Wheezy</em>, d'abord avec le même simple <code>apt-get install r-base</code> en root également, mais en fait j'ai constaté plus tard que la version des dépôts ne permet pas toujours d'installer les <em>libraries</em> voulue, donc il est préférable d'ajouter le dépôt <em>C-RAN</em>, comme indiqué là : <a href="http://cran.r-project.org/bin/linux/debian/README.html" class="uri">http://cran.r-project.org/bin/linux/debian/README.html</a>. Il manque juste l'info sur la clé publique du dépôt. Un <code>gpg --keyserver subkeys.pgp.net --recv-key 381BA480</code> a bien fonctionné de mon côté.</p>
<p>Pour <em>RStudio</em>, il faut télécharger le paquet ad hoc, par exemple le <em>rpm</em> ou le <em>deb</em> et l'installer avec <code>yum</code> ou <code>apt-get</code>, ceci afin d'avoir bien toutes les dépendances. Du moins, c'est ce que j'ai constaté. Et c'est parti.</p>
<h2 id="tm-et-wordcloud"><em>tm</em> et <em>wordcloud</em></h2>
<p>La première chose à faire, c'est de se munir d'un corpus de texte(s), s'il(s) est (sont) en <code>.txt</code>, c'est mieux. Pour ma part, pour mon premier test, j'ai pensé à du Flaubert, va savoir pourquoi. Dans ce genre de situation, j'ai bien aller sur <a href="http://www.gutenberg.org/"><em>Project Gutenberg</em></a>, parce qu'on y trouve des œuvres en format texte, et j'ai même trouvé <a href="http://www.gutenberg.org/cache/epub/14155/pg14155.txt"><em>Madame Bovary</em></a> en français, assez facilement pour une fois. Je l'ai téléchargé, enregistré à quelque part. Je l'ai un brin &quot;nettoyé&quot; avec un éditeur de texte pour supprimer les infos ajoutées par le projet en anglais, avant et après le texte, ce qui a dû me prendre une minute.</p>
<p>On peut ouvrir <em>RStudio</em> et installer les <em>libraries</em> dont on a besoin : <em>tm</em> pour le <em>text mining</em>, <em>wordcloud</em> pour le wordcloud, si, si, je te jure, et en testant j'ai vu qu'il était utile d'installer aussi <em>SnowballC</em> pour faire du <em>stemming</em>. Plusieurs manière de le faire, soit avec les commandes, soit avec l'interface graphique de <em>RStudio</em>, ce qui revient quand même au même :</p>
<pre><code>install.packages(&quot;tm&quot;)
install.packages(&quot;wordcloud&quot;)
install.packages(&quot;SnowballC&quot;)</code></pre>
<p>Ce qui doit pouvoir se simplifier en <code>install.packages(c(&quot;tm&quot;,&quot;wordcloud&quot;,&quot;SnowballC&quot;)</code>. En passant par l'interface graphique, ça se passe dans la fenêtre en bas à droite, l'onglet <em>Packages</em>, bouton <em>Install</em>. Un fois les paquets installés, on peut se lancer dans le script lui-même.</p>
<p>On commence par charger les <em>libraries</em> nécessaires :</p>
<pre><code>library (&quot;tm&quot;)
library (&quot;wordcloud&quot;)
library (&quot;SnowballC&quot;)</code></pre>
<p>Puis, on crée le corpus :</p>
<pre><code>bovary &lt;- Corpus(DirSource(&quot;~/informatique/R/wordcloud/tmp/&quot;, encoding = &quot;UTF-8&quot;), readerControl = list(reader=readPlain, language=&quot;fr&quot;))</code></pre>
<p><code>bovary</code> est le nom que j'ai donné au corpus. <code>Corpus</code> est une commande qui crée un corpus à partir de textes. Le <code>DirSource</code> donne le chemin vers le dossier qui contient le ou les textes à intégrer dans le corpus. On voit que l'on peut préciser l'encodage des textes. Attention, tous les textes contenus dans le dossiers vont être traités... <code>readerControl</code> précise quel lecteur il faut utiliser et la langue. En réalité, la commande proposée par le tutoriel cité plus haut fonctionne tout aussi bien :</p>
<pre><code>bovary &lt;- Corpus(DirSource(&quot;~/informatique/R/wordcloud/tmp/&quot;)</code></pre>
<p>Puis, il s'agit de préparer le textes en supprimant les espaces surnuméraires, les majuscules, les mots vides (<em>stop words</em>) et la ponctuation.</p>
<pre><code>bovary &lt;- tm_map(bovary, stripWhitespace)
bovary &lt;- tm_map(bovary, content_transformer(tolower))
bovary &lt;- tm_map(bovary, removeWords, c(stopwords(&quot;fr&quot;), &quot;comme&quot;, &quot;tout&quot;, &quot;plus&quot;, &quot;deux&quot;, &quot;bien&quot;, &quot;quand&quot;, &quot;quelque&quot;, &quot;peu&quot;, &quot;puis&quot;, &quot;tous&quot;, &quot;toute&quot;, &quot;toutes&quot;, &quot;oui&quot;, &quot;non&quot;))
bovary &lt;- tm_map(bovary, removePunctuation)</code></pre>
<p>Ce que j'ai remarqué, c'est qu'on obtient de meilleurs résultats en supprimant les mots vides avant d'enlever la pontctuation. Je me suis en effet retrouvé avec beaucoup de mots comme &quot;jai&quot; ou &quot;cétait&quot;. Je pense que c'est aussi que la liste des mots vides doit être améliorée. Il ne serait pas inutile de regarder de plus près les possibilités de <code>tm</code> en langue française. Dans la commande <code>removeWords</code>, j'ai ajouter quelques mots qu'il m'a semblé utile de supprimer aussi. J'y suis arrivé en tâtonnant, ce qui n'est pas très rigoureux...</p>
<p>Enfin, on peut générer le wordcloud :</p>
<pre><code>wordcloud(bovary, scale=c(3.5,0.35), max.words=120, random.order=FALSE, rot.per=0.35, use.r.layout=FALSE, colors=brewer.pal(8, &quot;Dark2&quot;))</code></pre>
<p>Donc on applique la commande <code>wordcloud</code> sur le corpus traité. <code>scale</code> paramètre les tailles relatives des grandes lettres et des petites. J'ai dû pas mal jouer avec ce paramètre en supprimant des mots, sinon j'obtiens des erreurs, parce qu'il n'est pas possible d'afficher tous les mots. <code>rot.per</code> détermine le pourcentage de mots qui seront affichés verticalement. Le dernier argument correspond aux couleurs. On peut connaître la liste des palettes possibles avec la commande <code>display.brewer.all()</code>.</p>
<p>Une fois le nuage généré, on peut l'exporter en format image. J'ai testé le <code>SVG</code>, mais le résultat n'est pas terrible, avec les mots qui se chevauchent. Je n'ai pas réussi à comprendre pourquoi. Mais en <code>PNG</code>, le résultat est relativement satisfaisant.</p>
